<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="数据与存储" _note="在 ZooKeeper 中，数据存储分为两部分：内存数据存储与磁盘数据存储。">
  <outline text="数据同步" _note="数据同步过程就是 Leader 服务器将那些没有在 Learner&#10;服务器上提交过的事务请求同步给 Learner 服务器。">
    <outline text="Learner 服务器向 Leader 申请注册" _note="整个集群完成 Leader 选举之后，Learner 服务器（Follower 或&#10;Observer）就会通过`registerWithLeader(Leader.FOLLOWERINFO);`或`registerWithLeader(Leader.OBSERVERINFO);`向&#10;Leader 服务器申请进行注册。&#10;&#10;而 Leader 在接受到这个消息后，也创建一个用来处理与当前 Learner&#10;服务器通信的`LearnerHandler`线程，并通过`QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO，ZxidUtils.makeZxid(newEpoch，0)，ver，null);oa.writeRecord(newEpochPacket，&quot;packet&quot;);bufferedOutput.flush();`向它表示「自己已经收到申请信息了，且期待它的回复」；随后`LearnerHandler`线程就进入阻塞等待状态，静候&#10;Learner 服务器回复确认。">
    </outline>
    <outline text="获取 Learner 服务器状态" _note="在注册 Learner 的最后阶段，Learner&#10;服务器会通过`QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH，lastLoggedZxid，epochBytes，null);writePacket(ackNewEpoch，true);`向&#10;Leader 服务器发送一个「ACKEPOCH 」数据包，Leader&#10;会从这个数据包中解析出该 Learner 的`currentEpoch`和`lastZxid`。&#10;&#10;在这之后，Learner&#10;服务器就会通过`syncWithLeader(newEpochZxid);`进入数据同步环节。">
    </outline>
    <outline text="数据同步初始化" _note="其实在开始数据同步之前，Leader 服务器会进行数据同步初始化。&#10;&#10;首先会通过`leader.zk.getZKDatabase().getCommittedLog();`从 ZooKeeper&#10;的内存数据库中提取出事务请求对应的提议缓存队列`proposals`，同时完成对以下三个&#10;ZXID 值的初始化：&#10;&#10;1.  peerLastZxid ：该 Learner 服务器最后处理的 ZXID&#10;&#10;2.  minCommittedLog ：Leader 服务器提议缓存队列`committedLog`中的最小&#10;    ZXID&#10;&#10;3.  maxCommittedLog ：Leader 服务器提议缓存队列`committedLog`中的最大&#10;    ZXID&#10;&#10;在初始化阶段，Leader 服务器会优先初始化以全量同步方式来同步数据。">
    </outline>
    <outline text="直接差异化同步（DIFF 同步）">
      <outline text="场景" _note="`peerLastZxid`在`[minCommittedLog，maxCommittedLog]`内">
      </outline>
      <outline text="过程">
        <outline text="发起差异化同步" _note="Leader 服务器会首先将该 LearnerHandler&#10;加入到`forwardingFollowers`或`observingLearners`队列中，这两个队列在&#10;ZooKeeper 运行期间的事务请求处理过程中都会使用到。&#10;&#10;然后通过`oa.writeRecord(new QuorumPacket(packetToSend，zxidToSend，null，null)，&quot;packet&quot;);`向这个&#10;Learner 发送一个「DIFF」指令，用于通知 Learner&#10;进入差异化数据同步阶段，Leader 服务器会把一些 Proposal 同步过去。&#10;&#10;在同步过程中，针对每个 Proposal，Leader&#10;服务器都会通过`queuePacket(propose.packet);QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT，propose.packet.getZxid()，null，null);queuePacket(qcommit);`将需要向&#10;Learner&#10;服务器发送「PROPOSAL」内容数据包和「COMMIT」指令数据包放入`queuedPackets`队列中。&#10;&#10;随后 Leader&#10;还会将一个「NEWLEADER」指令也放入`queuedPackets`队列中，它用于通知&#10;Learner，表示自己已经将提议缓存队列`proposals`中的 Proposal&#10;都同步过去了。&#10;&#10;最后 Leader&#10;服务器启动一个线程，并让线程通过`sendPackets`方法将`queuedPackets`队列中消息全部发送给&#10;Learner 服务器。">
        </outline>
        <outline text="同步确认" _note="按照 Leader 服务器的数据包发送顺序，Learner&#10;会首先接收到一个「DIFF」指令，接下来进入 DIFF 同步阶段。&#10;&#10;对于依次收到数据包，Learner&#10;会依次将其应用到内存数据库中。对于一个「PROPOSAL」内容数据包的内容，Learner&#10;会将其放入`packetsNotCommitted`队列中；若紧接着再收到一个对应的「COMMIT」指令，则会将这个提议从`packetsNotCommitted`队列中移除，并通过`zk.processTxn(pif.hdr，pif.rec);`将事务应用到内存数据库中。&#10;&#10;处理完事务的数据包后，Learner 还会接收到来自 Leader&#10;的「NEWLEADER」指令，此时 Learner&#10;就会通过`writePacket(new QuorumPacket(Leader.ACK，newLeaderZxid，null，null)，true);`反馈给&#10;Leader 一个「ACK」消息，表明自己也确实完成了对提议缓存队列中 Proposal&#10;的同步工作。&#10;&#10;Leader 在接收到来自 Learner 的这个「ACK」消息以后，就认为当前 Learner&#10;已经完成了数据同步，同时通过`leader.waitForNewLeaderAck(getSid()，qp.getZxid()，getLearnerType());`进入「过半策略」等待阶段。Leader&#10;会和其他 Learner 服务器进行上述同样的数据同步流程，直到集群中有过半的&#10;Learner 机器响应了 Leader 这个「ACK」消息。&#10;&#10;一旦满足「过半策略」后，Leader&#10;服务器就会启动心跳检测器`SyncLimitCheck`，并等待 Leader&#10;服务器正式处于运行状态后，通过`queuedPackets.add(new QuorumPacket(Leader.UPTODATE，-1，null，null));`向所有已经完成数据同步的&#10;Learner 发送一个「UPTODATE」指令，用来通知 Learner&#10;已经完成了数据同步，同时集群中已经有过半机器完成了数据同步，集群已经具备了对外服务的能力了。&#10;&#10;Learner 在接收到这个来自 Leader&#10;的「UPTODATE」指令后，会终止数据同步流程，然后通过`QuorumPacket ack = new QuorumPacket(Leader.ACK，0，null，null);...;ack.setZxid(ZxidUtils.makeZxid(newEpoch，0));writePacket(ack，true);`再向&#10;Leader 发送一个「ACK」消息。&#10;&#10;Learner&#10;最后还会对`packetsNotCommitted`队列中剩余的数据进行处理，并将其交给对应的请求处理器进行处理：如果是&#10;Follower&#10;，则会通过`fzk.logRequest(p.hdr，p.rec);`将`packetsNotCommitted`中的提议提交给`SyncRequestProcessor`，并通过`fzk.commit(zxid);`将服务器未处理过的事务提交给`CommitProcessor`。">
        </outline>
      </outline>
    </outline>
    <outline text="先回滚再差异化同步（TRUNC + DIFF 同步）">
      <outline text="场景" _note="Leader 服务器在已经将事务记录到了本地事务日志中，但是没有成功发起&#10;Proposal 流程时就挂了。">
      </outline>
      <outline text="过程" _note="当 Leader 服务器发现某个 Learner&#10;包含了一条自己没有的事务记录，那么就需要让该 Learner&#10;进行事务回滚：回滚到 Leader&#10;服务器上存在的，同时也是最接近于`peerLastZxid`的 ZXID。">
      </outline>
    </outline>
    <outline text="仅回滚同步（TRUNC 同步）">
      <outline text="场景" _note="`peerLastZxid`大于`maxCommittedLog`">
      </outline>
      <outline text="过程" _note="Leader 会要求 Learner 回滚到 ZXID 值为`maxCommitedLog`对应的事务操作">
      </outline>
    </outline>
    <outline text="全量同步（SNAP 同步）" _note="指在某些场景下，Leader 服务器无法直接使用提议缓存队列和 Learner&#10;进行数据同步，因此 Leader 服务器只能将本机上的全部内存数据都同步给&#10;Learner。">
      <outline text="场景" _note="1.  `peerLastZxid`小于`minCommittedLog`&#10;&#10;&amp;nbsp;&#10;&#10;1.  Leader 服务器上没有提议缓存队列，`peerLastZxid`不等于 Leader&#10;    服务器数据恢复后得到的最大ZXID`lastCommittedLog`">
      </outline>
      <outline text="过程" _note="Leader 服务器首先向 Learner 发送一个「SNAP」指令，通知 Leamer&#10;即将进行全量数据同步。&#10;&#10;随后 Leader&#10;会通过`leader.zk.getZKDatabase().serializeSnapshot(oa);`将内存数据库中获取到全部数据节点和会话超时时间记录器进行序列化，并将它们&#10;dump 给 Learner。&#10;&#10;Learner 服务器接收到该全量数据后，会对其反序列化后载入到内存数据库中。">
      </outline>
    </outline>
  </outline>
</outline>
  </body>
</opml>
