# ZooKeeper

这是一个分布式协调服务框架，是Apache Hadoop 的一个子项目。

可以用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。

举个例子，分布式协调服务很难做好，特别容易出现竞争条件和死锁等错误，而使用 ZooKeeper 可以降低分布式应用从零开始实现协调服务的难度。

[ZooKeeper 官网文档](https://zookeeper.apache.org/doc/current/zookeeperOver.html)

## 核心概念

### 集群角色

#### Leader 

状态为 LEADING 的节点，为客户端提供读写服务。

主导「过半写成功」策略，即将写事务请求同步给其他节点，且需要保证事务的顺序性。

#### Follower

状态为 FOLLOWING 的节点，能提供读服务。

参与 Leader 选举，也参与「过半写成功」策略（将写事务请求转发给 Leader）。

#### Observer

状态为 OBSERING 的节点，能提供读服务。

不参与 Leader 选举，也不参与「过半写成功」策略。

可以用来线性扩展集群的 QPS 性能。

### Session（会话）

客户端会话

### Znode（数据节点）

在 ZooKeeper 中，节点分为两类，一种是构成集群的机器节点，另一种是数据模型中的数据单元，即数据节点

ZooKeeper 将所有数据存储在内存中，数据模型是一颗文件树

Znode 是 ZooKeeper 中数据的最小单元，每个 Znode 都可以保存数据，还可以挂载子节点

通过 Znode 可以实现数据的原子性读写，但每个 Znode 存储的数据很小，通常在1MB 以内。

#### Znode 类型

##### PERSISTENT - 持久化目录节点

除非主动进行移除，否则该节点将一直保存在 ZooKeeper 上

##### EPHEMERAL - 临时节点

该节点的生命周期与客户端绑定，当客户端会话失效时，该节点将被删除

##### PERSISTENT_SEQUENTIAL/EPHEMERAL_SEQUENTIAL - （持久化/临时）顺序节点

当这个节点被创建时，ZooKeeper 会自动在节点名后追加一个整型数字，该数字是一个由父节点维护的自增数

分为持久化节点和临时节点两种

### 版本

在 Znode 中维护了一个数据结构 Stat，记录了每个 Znode 都具有的三种不同类型的版本信息：version （当前 Znode 数据内容的版本号）、cversion（当前 Znode 子节点的版本号）和 aversion （当前 Znode 的 ACL 变更版本号）

版本的实质是数据内容、子节点或者 ACL 的修改次数

ZooKeeper 通过这种特性保障了乐观锁机制的实现


### Watcher（事件监听器）

ZooKeeper 允许客户端注册一些 Watcher，去监听它关心的目录节点，而且当目录节点发生变化（如数据改变、被删除、子目录节点增加删除）时，ZooKeeper 会将事件通知客户端

#### 特性

##### 一次性

无论是服务端还是客户端，一个 Watcher 一旦被触发，ZooKeeper 都会想起从相应的储存中移除

这样的设计有效地减轻了服务器的压力

开发人员需要注意在 Watcher 的使用上要反复注册

##### 客户端串行执行

客户端 Watcher 回调的过程是一个串行同步的过程，这保证了顺序性。

开发人员需要注意千万不要因为一个 Watcher 的处理逻辑影响了整个客户端的 Watcher 回调

##### 轻量级

WatchedEvent 是 ZooKeeper 整个 Watcher 通知机制的最小通知单元，整个数据结构中只包含了三部分：通知状态、事件类型和节点路径

也就是说 Watcher 通知只会告诉客户端在哪里发生了什么事件，而不会说明事件的具体内容，这需要客户端主动去重新获取数据

另外，客户端向服务端注册 Watcher 时，并不会把客户端真实的 Watcher 对象传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记，同时服务端也仅仅只是保存了当前连接的 ServerCnxn 对象

### ACL（访问控制列表 ，Access Control Lists ）策略

ZooKeeper 采用 ACL 来进行权限控制，类似于 UNIX 文件系统的权限控制。

##### 权限

**CREATE**：创建**子节点**的权限

**READ**：获取节点数据和子节点列表的权限

**WRITE**：更新节点数据的权限

**DELETE**：删除**子节点**的权限

**ADMIN**：设置节点 ACL 的权限

## 保证

### 1. 顺序一致性

ZooKeeper 是主从模型，因此所有的写操作都会在「主节点」上执行，即由单机来维护客户端指令的顺序与他们发送至 ZooKeeper 的顺序一致一致。

### 2. 原子性

在 ZooKeeper 中，事务是指能够改变 ZooKeeper 服务器状态的操作。一般包括 Znode 的创建与删除、内容更新和 Session 创建与失效等操作。

类似事务的原子性，一条命令发送到 ZooKeeper 集群，要么执行成功要么失败，没有中间状态。

### 3. 单一系统映像

客户端将看到相同的服务视图，而不管它连接到集群中的哪一台 ZooKeeper 服务器。

### 4. 可靠性（持久性）

一旦应用更新，数据将被持久化，直到数据被再次更新。

对于该保证有两个推论：

1、如果客户端得到了成功的返回码，说明写入成功，数据被持久化，如果出现了通信错误，超时等一些故障，客户端将不知道更新是否已应用。我们采取措施尽量减少失败，但唯一的保证是只有成功的返回码。 （这在Paxos中称为单调性条件。）

2、如果客户端已经读取到了数据或者写入成功了数据，都不会因为zk的失败而导致回滚。

### 5. 及时性（最终一致性）

客户端看到的服务视图保证在特定时间范围内是最新的。

# ZAB （ZooKeeper Atomic Broadcast）协议

特别为 ZooKeeper 设计的、支持崩溃恢复的原子广播协议，是一种类似于 2PC 的协议。

通过 ZAB 协议，ZooKeeper 可以进行集群间主备节点的数据同步，保证数据的一致性。

[深入浅出 Zookeeper 中的 ZAB 协议](https://network.51cto.com/article/704705.html)

## 协议具体内容

ZAB 协议包括两种基本模式：数据恢复模式和消息广播模式。

当 ZooKeeper 处于启动过程中，或者当 Leader 挂了时，亦或者集群中已经不存在过半的服务器与 Leader 保持正常通信时，ZAB 协议就会**进入数据恢复模式**并选举产生新的 Leader。

当选举产生了新的Leader，同事集群中已经有过半的机器与该 Leader 完成了状态同步之后，ZAB 协议就会**进入消息广播模式**。

当一台同样遵守 ZAB 协议的服务器**新加入集群**时，就会自觉进入数据恢复模式，即找到 Leader ，并与其进行数据同步，然后一起参与到消息广播流程中去。

### 消息广播模式

在消息广播过程中，Leader 会为每个 Follower 都分配一个单独队列，然后将需要广播的 Proposal 依次放入这些 FIFO 队列中去。

每一个 Follower 在接收到一个 Proposal 之后，都会先以事务日志的形式写入到本地磁盘，并在成功写入后，反馈给 Leader 一个 Ack 响应。

当 Leader 收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有 Follower 以通知其进行事务提交，同时 Leader 自身也会完成对事务的提交。

每一个 Follower 在接收到一个 Commit 消息之后，都会完成对事务的提交。

### 崩溃恢复模式

#### 基本特性

确保 Follower 提交「已经在 旧Leader 上提交的事务」，同时确保旧 Leader 丢弃「只在旧Leader 上被提出的事务」

#### ZooKeeper 选举

以**服务器启动时期**的 Leader 选举为例子

##### 1.  投票给自己

投票信息（Vote）包含节点ID (SID) 和事务ID（ZXID）

SID 是配置好的，而且是唯一的，和 myid 的值一样；ZXID 是唯一的递增编号

###### ZXID （事务ID）

ZXID 是一个64位整数，对于每一个事务请求，ZooKeeper 都会为其分配一个全局唯一的事务ID。

其中低32位是一个单调递增的事务计数器，当客户端的每一个事务请求，或者 Leader 产生的每一个事务，其值都会加1

高32位则代表了 Leader 周期 epoch 的编号，当选举产生一个新的 Leader 时，该值就会变成「新 Leader 本地日志中最大事务的 ZXID 的 epoch 值 + 1」；通过 epoch 能够有效地避免不同的 Leader 错误使用相同 ZXID 编号提出不一样事务的

通过 ZXID ，我们可以间接地识别出 ZooKeeper 处理这些更新操作请求的全局顺序。

##### 2. 将投票信息发给集群中的其他节点

##### 3. 处理投票

针对来自其他节点的每一个投票，「节点X」都需要将其与自己的投票进行判断、PK和更新投票信息三个操作。

当「节点X」没有需要处理的投票时，它会将投票信息向集群中的所有节点发送出去（即便最后的PK结果是「节点X」自己的投票被选中了）。

###### 3.1 判断

「节点X」判断另一个节点发来的投票**是否是本轮投票**，以及该节点**是否处于 LOOKING 状态**

###### 3.2 PK

「节点X」会将自己的投票和另一个节点发来的投票进行 PK

比较规则如下：

优先选取 ZXID 较大的投票；如果 ZXID 相等，则优先选取 SID 较大的投票

###### 3.3 更新投票信息

「节点X」根据PK结果将投票信息更新。

##### 4. 统计投票

每一轮投票，「节点X」都会统计所有节点的投票信息，判断是否有某个节点的票数达到了过半机器数（Quorum）

如果有，就将该节点作为 Leader

如果集群中的总节点数为 n，Quorum = `( n/2 + 1 )`

##### 5. 更新节点状态：

一旦确定了 Leader，每个节点就会更新自己的节点状态

Leader，更新节点状态为 LEADING

其他节点作为 Follower，更新节点状态为 FOLLOWING

##### 服务器运行期间的 Leader 选举

当 Leader 挂了之后，余下的非 Observer 节点都会将自己的节点状态变更为 LOOKING

除了上述步骤外的其他选举步骤，与启动期间区别不大。

#### 数据同步

所有正常运行的节点，要么成为 Leader ，要么成为 Follower 并与 Leader 保持同步。

所以完成 Leader 选举之后，Leader 首先会确认事务日志中的所有 Proposal 是否都已经被集群中过半的机器提交了

只有确认完成，ZooKeeper 集群才能正式开始工作（即接受客户端的事务请求，然后提出新的提案）

##### 1. Leader 发送数据

Leader 会为每一个 Follower 准备一个队列，并将那些没有被各 Follower 同步的事务以 Proposal 消息的方式逐个发送给 Follower，并在 每一个 Proposal 消息后面紧接着发送一个 Commit 消息，表示该事务已经被提交。

##### 2. Follower 确认数据

Follower 会将所有尚未同步的 Proposal 都同步过来，并成功应用到本地数据库中

##### 3. Leader 将 Follower 加入到可用列表中

##### 策略

1.新选举出来的 Leader 拥有集群中最大的 ZXID ，表示新 Leader 一定具有所有已经提交的提案，包括「已经在 旧Leader 上提交的事务」

2.旧 Leader 在恢复后，将会与新 Leader 进行数据同步，对于「只在旧Leader 上被提出的事务」，由于其 ZXID 小于新 Leader 的最大ZXID，因此将被丢弃
