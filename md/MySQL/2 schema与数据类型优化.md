# 数据类型的优化

## 通用优化规则

### 更小的通常更好

```Java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;

public class Test {
    public static void main(String[] args) throws Exception{
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db1","root","123456");
        PreparedStatement pstmt = conn.prepareStatement("insert into psn2 values(?,?)");
        for (int i = 0; i < 20000; i++) {
            pstmt.setInt(1,i);
            pstmt.setString(2,i+"");
            pstmt.addBatch();
        }
        pstmt.executeBatch();
        conn.close();
    }
}

```

### 简单就好

简单数据类型的操作通常需要更少的CPU周期，例如，

1、整型比字符操作代价更低，原因在于字符集和校对规则导致：字符比较比整型比较更复杂

2、使用MySQL自建类型date来存储日期和时间，而不是字符串

使用字符串存储日期类型，占用空间大，还损失了日期类型函数的便捷性

测试：创建两张相同的表，改变日期的数据类型，查看SQL语句执行的速度

3、用整型存储IP地址：使用MySQL函数 `INET_ATON`

### 尽量避免null

如果查询中包含可为NULL的列，对MySQL来说很难优化，因为可为NULL的列使得索引、索引统计和值比较都更加复杂

坦白来说，通常情况下NULL的列改为NOT NULL带来的性能提升比较小，所有没有必要将所有的表的schema进行修改，但是应该尽量避免设计成可为NULL的列

### 灵活使用数据类型

MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过**对不同表、不同字段，使用不同的数据类型**来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。

## 实际细则

### 整数类型

可以使用的几种整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT

分别使用8，16，24，32，64位存储空间

尽量使用可以满足需求的最小数据类型

### 字符和字符串类型

查询速度：`char > varchar > text`

#### char

长度固定，每条数据占用等长字节的空间

最大长度是255个字符

会自动删除末尾的空格

**检索效率、写效率**比 varchar 高，以空间换时间

##### 应用场景

1、存储长度波动不大的数据，如：md5摘要、身份证号等
2、存储短字符串、经常更新的字符串，如：手机号等

#### varchar(n)

varchar长度可变，可以设置最大长度

最大空间是65535个字节，但是存储长度实际最大可用值为**65532（允许非空字段）**或 **65533（不允许非空字段）**，起始位和结束位占去了2个字节。

mysql的vachar字段的类型虽然最大长度是65535，但是并不是能存这么多数据，最大可以到65533（不允许非空字段的时候）。

根据实际内容，使用可以满足需求的最小长度保存数据

##### 额外长度

n<=255时，使用额外一个字节保存长度

n>255时，使用额外两个字节保存长度。

##### 内存空间占用

以`varchar(5)` 与 `varchar(255) ` 为例：

让它们保存同样的内容，硬盘存储空间虽然都是根据实际字符长度来分配存储空间的，但是对于内存来说，则是使用固定大小的内存块来保存值。

简单的说，`varchar(255) ` 会使用字符类型中定义的长度，即255个字符空间。

这对于排序或者临时表（**这些内容都需要通过内存来实现**）作业会产生比较大的不利影响。

##### 变更长度

在 mysql5.6 之前变更长度，或者从255以下变更到255以上时时，都会导致锁表。

##### 应用场景

1、存储长度波动较大的数据，如：文章，有的会很短有的会很长
2、字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度
3、适合保存多字节字符，如：汉字，特殊字符等

#### text

长度不需设置，会用额外空间存放数据长度

最大空间是65535个字节，可以全部使用。

因此当不知道属性的最大长度时，适合用 text

### BLOB和TEXT类型

MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。

两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。

### 时间类型

1、不要使用字符串类型来存储日期时间数据

2、日期时间类型通常比字符串占用的存储空间小

3、日期时间类型在进行查找过滤时可以利用日期来进行比对

4、日期时间类型还有着丰富的处理函数，可以方便的对时间类型进行日期计算

5、使用int存储日期时间不如使用timestamp类型

#### 	datetime

占用8个字节
与时区无关，数据库底层时区配置，对 datetime 无效
可保存到毫秒
可保存时间范围大（1000-9999年）

#### 	timestamp

占用4个字节
时间范围：1970-01-01到2038-01-19
精确到秒
采用整形存储
依赖数据库设置的时区
自动更新timestamp列的值

#### 	date

占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节
使用date类型还可以利用日期时间函数进行日期之间的计算
date类型用于保存1000-01-01到9999-12-31之间的日期

### 使用枚举代替字符串类型

有时可以使用枚举类代替常用的字符串类型，mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表

```sql
create table enum_test(e enum('fish','apple','dog') not null);

insert into enum_test(e) values('fish'),('dog'),('apple');

select e+0 from enum_test;

alter table enum_test modify e enum('fish', 'dog', 'apple') not null primary key ;

select e+0 from enum_test where e = 'dog';
```

### 特殊类型数据

人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换

案例：

```sql
select inet_aton('1.1.1.1')

select inet_ntoa(16843009)
```

### 操作系统读取磁盘时的概念，磁盘预读（4KB）和局部性原理

# 合理使用范式和反范式

## 范式

### 优点

1.范式化的更新通常比反范式要快

2.当数据较好的范式化后，很少或者没有重复的数据

3.范式化的数据比较小，可以放在内存中，操作比较快

###  缺点

通常需要进行关联

### 键

#### 超键

在关系中能唯一标识元组的属性集称为关系模式的超键

#### 候选键

不含有多余属性的超键称为候选键，也称最小超键

##### 主属性

包含在任何一个候选键中的属性

##### 非主属性（非键）

不包含在任何一个候选键中的属性

#### 主键

若候选键多于一个，选定一个候选键作为主键

### 类型

#### 1NF

列不可分割

#### 2NF（在满足 1NF 的基础上，消除非主属性对键的部分函数依赖）

表必须有主键（非主属性都必须完全函数依赖于候选键）

#### 3NF（在满足 2NF 的基础上，消除非主属性对键的传递函数依赖）

任何非主属性都直接依赖于主属性，不能传递依赖于主属性。

#### BCNF（在满足 3NF 基础上，消除主属性对键的部分和传递函数依赖）

##### 决定因素都为键

所有非主属性对每一个键都是完全函数依赖（即非主属性不能对主键子集依赖）
所有主属性对每一个不包含它的键也是完全函数依赖
没有任何属性完全依赖于非主的任何一组属性

##### 非主属性均 既不部分依赖于候选键 也不传递依赖于候选键 且候选键均包含主键

#### 4NF（在满足巴斯-科德范式（BCNF）的基础上，消除非平凡的且非函数依赖的多值依赖）

删除同一表内的多对多关系

##### 函数传递的局限

函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。

##### 多值依赖

属性之间的一对多关系，记为K→→A

##### 平凡的多值依赖

全集U=K+A，一个K可以对应于多个A，即K→→A。
此时整个表就是一组一对多关系。

##### 非平凡的多值依赖

全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B互相独立，即K→→A，K→→B。

###### 整个表有多组一对多关系

“一” 部分是相同的属性集合
“多” 部分是互相独立的属性集合

## 反范式

### 优点

1.所有的数据都在同一张表中，可以避免关联
2.可以设计有效的索引；

### 缺点

表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失

## 应用

### 在企业中很少能做到严格意义上的范式或者反范式，一般需要混合使用

1.在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。  在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。
2.另一个从父表冗余一些数据到子表的理由是排序的需要。
3.缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。
### 案例

#### 范式设计

#### 反范式设计

### 使用代理主键

#### 代理主键

与业务无关的，无意义的数字序列

不与业务耦合，因此更容易维护
一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本

#### 自然主键

事物属性中的自然唯一标识

# 字符集的选择

## 1.优先使用拉丁字符

纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间。

## 2.非必要不使用UNICODE

如果我们可以确定不需要存放多种语言，就没必要非得使用 UTF8 或者其他UNICODE字符类型，因为这会造成大量的存储空间浪费。

##### 不使用 utf8，改用 utf8mb4

MySQL在5.5.3之后增加了这个utf8mb4的编码，是utf8的超集
mb4就是most bytes 4的意思，专门用来兼容四字节的unicode

原来mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。

# 存储引擎的选择

## 存储引擎的对比

InnoDB支持表级锁和行级锁，可以给索引加锁时，使用行级锁，否则使用表级锁。
存储引擎指，存储文件的组织形式

# 适当的数据冗余

对于被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段，对其进行数据冗余是非常明智的。

由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。

不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。

# 适当拆分

当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。

这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。
