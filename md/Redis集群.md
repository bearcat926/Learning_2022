# Redis 集群篇

## Redis Sentinel（哨兵）

将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，它会持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。

### 过程

1. 客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。
2. 当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。
   1. 而某个从节点会被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。
   2. 客户端将与新的主节点继续进行交互。
3. Sentinel 会持续监控已经挂掉的主节点，待它恢复后，将会变成从节点，并从新的主节点那里建立复制关系。

此时原先挂掉的主节点现在变成了从节点，从新的主节点那里建立复制关系。

### 消息丢失

Redis 主从采用异步复制，这意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。

如果主从延迟特别大，那么丢失的数据就可能会特别多。

Sentinel **无法保证消息完全不丢失，但是也尽可能保证消息少丢失**。

有两个选项可以限制主从延迟过大：

`min-slaves-to-write 1` 表示主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。
`min-slaves-max-lag 10` 表示如果 10s 没有收到从节点的反馈，就意味着从节点同步异常，要么网络断开了，要么一直没有给反馈。

### 基本使用

sentinel 的默认端口是 26379

Python 使用方法：

通过 sentinel 对象的 discover_xxx 方法可以发现主从地址，主地址只有一个，从地址可以有多个。

通过 xxx_for 方法可以从连接池中拿出一个连接来使用，因为从地址有多个，redis 客户端对从地址采用轮询方案，也就是 RoundRobin 轮着来。

### 问题

#### sentinel 进行主从切换时，客户端如何知道地址变更了 ?

#### 如果是 sentinel 主动进行主从切换，主库并没有挂掉，而之前的主库连接已经建立了在使用了，那这样会不会导致切换不一致？

## Codis

### 在大数据高并发场景下，单个 Redis 实例的缺陷

#### 1.单个 Redis 的内存不宜过大

内存太大会导致 rdb 文件过大

-> 进一步导致主从同步时全量同步时间过长

-> 在实例重启恢复时也会消耗很长的数据加载时间

#### 2.CPU 利用率过高

单个 Redis 实例只能利用单个核心，这单个核心要完成海量数据的存取和管理工作压力会非常大。

### 特点

#### 使用 Redis 协议

Codis 使用 Redis 协议对外提供服务，由此可以实现：

将客户端发送的指令时，转发到后面的 Redis 实例来执行，

并将Redis 实例返回的结果再转回给客户端。

#### 允许动态扩容

当Redis集群（即挂接在Codis 上的所有 Redis 实例）空间不足时，可以通过动态增加 Redis 实例来实现扩容需求

#### 操作无区别

客户端操纵 Codis 同操纵 Redis 几乎没有区别，还是可以使用相同的客户端 SDK，不需要任何变化。

#### 无状态

Codis 是无状态的，它只是一个转发代理中间件。

这意味着我们可以启动多个 Codis 实例供客户端使用，且每个 Codis 节点都是对等的。

### 分片原理

如何管理 Codis中特定的 key 转发到特定的 Redis 实例的对应关系？
Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。
